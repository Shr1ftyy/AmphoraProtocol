// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import "../_external/IERC20Metadata.sol";
import "../_external/openzeppelin/ERC20Upgradeable.sol";
import "../_external/openzeppelin/OwnableUpgradeable.sol";
import "../_external/openzeppelin/Initializable.sol";

import "IVaultController.sol";


/// @title CappedGovToken
/// @notice handles all minting/burning of underlying
/// @dev extends ierc20 upgradable
contract VotingVaultController is Initializable, OwnableUpgradeable, ERC20Upgradeable {
  uint8 private _underlying_decimals;
  IVaultController public _vaultController;
  mapping(uint96 => address) public _vaultId_votingVaultAddress;
  mapping(address => uint96) public _votingVaultAddress_vaultId;

  mapping(address => address) public _underlying_CappedToken;
  mapping(address => address) public _CappedToken_underlying;

  /// @notice register an underlying capped token pair
  /// note that registring a token as a capepd token allows it to transfer the balance of the corresponding token at will
  /// @param underlying_address address of underlying
  /// @param capped_token address of capped token
  function registerUnderlying(address underlying_address, address capped_token) external onlyOwner {
    _underlying_CappedToken[underlying_address] = capped_token;
    _CappedToken_underlying[capped_token] = underlying_address;
  }

  /// @notice unregister the pair
  /// @param underlying_address address of underlying
  /// @param capped_token address of capped token
  function unregisterUnderlying(address underlying_address, address capped_token) external onlyOwner {
    _underlying_CappedToken[underlying_address] = address(0x0);
    _CappedToken_underlying[capped_token] = address(0x0);
  }
  modifier onlyCappedToken() {
    require(_CappedToken_underlying[_msgSender()] != address(0x0));
    _;
  }

  function retrieveUnderlying(uint256 amount, address voting_vault, address target) public onlyCappedToken {
    require(voting_vault != address(0x0), "invalid vault")
    address underlying_address = _CappedToken_underlying[_msgSender()];
    require(underlying_address != address(0x0), "only capped token");
    IERC20Metadata underlying = IERC20Metadata(underlying_address);
    VotingVault votingVault = VotingVault(voting_vault);
    votingVault.votingVaultControllerTransfer(underlying_address, target, amount);
  }

  /// @notice initializer for contract
  /// @param name_ name of capped token
  /// @param symbol_ symbol of capped token
  /// @param underlying_ the address of underlying
  function initialize(
    string memory name_,
    string memory symbol_,
    address underlying_,
    address vaultController_,
  ) public initializer {
    __Ownable_init();
    __ERC20_init(name_, symbol_);
    _underlying = IERC20Metadata(underlying_);
    _underlying_decimals = _underlying.decimals();

    _vaultController = IVaultController(vaultController_);
  }

  event NewVault(address vault_address, uint256 vaultId, address vaultOwner);
  /// @notice create a new vault
  /// @return address of the new vault
  function mintVault(uint256 id) public override returns (address) {
    if(_vaultId_vaultAddress[_vaultsMinted] == address(0)) {
      address vault_address = _vaultController.vaultAddress(id);
      if(vault_address != address(0)) {
        // mint the vault itself, deploying the contract
        address voting_vault_address = address(new VotingVault(id,vault_address, address(this)));
        // add the vault to our system
        _vaultId_votingVaultAddress[id] = voting_vault_address;
        _votingVaultAddress_vaultId[voting_vault_address] = id;
        // emit the event
        emit NewVotingVault(vault_address, id, _msgSender());
      }
    }
    return _vaultId_vaultAddress[_vaultsMinted];
  }

  function vaultAddress(uint96 id) public override returns (address) {
    return _vaultId_votingVaultAddress[id];
  }

  function vaultId(address voting_vault_address) public override returns (uint96) {
    return _votingVaultAddress_vaultId[voting_vault_address];
  }

}
